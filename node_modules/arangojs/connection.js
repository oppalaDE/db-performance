"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = exports.isArangoConnection = void 0;
const x3_linkedlist_1 = require("x3-linkedlist");
const error_1 = require("./error");
const btoa_1 = require("./lib/btoa");
const codes_1 = require("./lib/codes");
const normalizeUrl_1 = require("./lib/normalizeUrl");
const querystringify_1 = require("./lib/querystringify");
const request_1 = require("./lib/request");
const MIME_JSON = /\/(json|javascript)(\W|$)/;
const LEADER_ENDPOINT_HEADER = "x-arango-endpoint";
function isBearerAuth(auth) {
    return auth.hasOwnProperty("token");
}
/**
 * @internal
 */
function generateStackTrace() {
    let err = new Error();
    if (!err.stack) {
        try {
            throw err;
        }
        catch (e) {
            err = e;
        }
    }
    return err;
}
/**
 * Indicates whether the given value represents a {@link Connection}.
 *
 * @param connection - A value that might be a connection.
 *
 * @internal
 */
function isArangoConnection(connection) {
    return Boolean(connection && connection.isArangoConnection);
}
exports.isArangoConnection = isArangoConnection;
/**
 * Represents a connection pool shared by one or more databases.
 *
 * @internal
 */
class Connection {
    /**
     * @internal
     *
     * Creates a new `Connection` instance.
     *
     * @param config - An object with configuration options.
     *
     */
    constructor(config = {}) {
        this._activeTasks = 0;
        this._arangoVersion = 30900;
        this._queue = new x3_linkedlist_1.LinkedList();
        this._databases = new Map();
        this._hosts = [];
        this._hostUrls = [];
        this._transactionId = null;
        this._queueTimes = new x3_linkedlist_1.LinkedList();
        const URLS = config.url
            ? Array.isArray(config.url)
                ? config.url
                : [config.url]
            : ["http://127.0.0.1:8529"];
        const MAX_SOCKETS = 3 * (config.loadBalancingStrategy === "ROUND_ROBIN" ? URLS.length : 1);
        if (config.arangoVersion !== undefined) {
            this._arangoVersion = config.arangoVersion;
        }
        this._agent = config.agent;
        this._agentOptions = request_1.isBrowser
            ? { maxSockets: MAX_SOCKETS, ...config.agentOptions }
            : {
                maxSockets: MAX_SOCKETS,
                keepAlive: true,
                keepAliveMsecs: 1000,
                scheduling: "lifo",
                ...config.agentOptions,
            };
        this._maxTasks = this._agentOptions.maxSockets;
        this._headers = { ...config.headers };
        this._loadBalancingStrategy = config.loadBalancingStrategy ?? "NONE";
        this._precaptureStackTraces = Boolean(config.precaptureStackTraces);
        this._responseQueueTimeSamples = config.responseQueueTimeSamples ?? 10;
        this._retryOnConflict = config.retryOnConflict ?? 0;
        if (this._responseQueueTimeSamples < 0) {
            this._responseQueueTimeSamples = Infinity;
        }
        if (config.maxRetries === false) {
            this._maxRetries = false;
        }
        else {
            this._maxRetries = Number(config.maxRetries ?? 0);
        }
        this.addToHostList(URLS);
        if (config.auth) {
            if (isBearerAuth(config.auth)) {
                this.setBearerAuth(config.auth);
            }
            else {
                this.setBasicAuth(config.auth);
            }
        }
        if (this._loadBalancingStrategy === "ONE_RANDOM") {
            this._activeHostUrl =
                this._hostUrls[Math.floor(Math.random() * this._hostUrls.length)];
            this._activeDirtyHostUrl =
                this._hostUrls[Math.floor(Math.random() * this._hostUrls.length)];
        }
        else {
            this._activeHostUrl = this._hostUrls[0];
            this._activeDirtyHostUrl = this._hostUrls[0];
        }
    }
    /**
     * @internal
     *
     * Indicates that this object represents an ArangoDB connection.
     */
    get isArangoConnection() {
        return true;
    }
    get queueTime() {
        return {
            getLatest: () => this._queueTimes.last?.value[1],
            getValues: () => Array.from(this._queueTimes.values()),
            getAvg: () => {
                let avg = 0;
                for (const [, [, value]] of this._queueTimes) {
                    avg += value / this._queueTimes.length;
                }
                return avg;
            },
        };
    }
    _runQueue() {
        if (!this._queue.length || this._activeTasks >= this._maxTasks)
            return;
        const task = this._queue.shift();
        let hostUrl = this._activeHostUrl;
        if (task.hostUrl !== undefined) {
            hostUrl = task.hostUrl;
        }
        else if (task.allowDirtyRead) {
            hostUrl = this._activeDirtyHostUrl;
            this._activeDirtyHostUrl =
                this._hostUrls[(this._hostUrls.indexOf(this._activeDirtyHostUrl) + 1) %
                    this._hostUrls.length];
            task.options.headers["x-arango-allow-dirty-read"] = "true";
        }
        else if (this._loadBalancingStrategy === "ROUND_ROBIN") {
            this._activeHostUrl =
                this._hostUrls[(this._hostUrls.indexOf(this._activeHostUrl) + 1) %
                    this._hostUrls.length];
        }
        this._activeTasks += 1;
        const callback = (err, res) => {
            this._activeTasks -= 1;
            if (!err && res) {
                if (res.statusCode === 503 && res.headers[LEADER_ENDPOINT_HEADER]) {
                    const url = res.headers[LEADER_ENDPOINT_HEADER];
                    const [cleanUrl] = this.addToHostList(url);
                    task.hostUrl = cleanUrl;
                    if (this._activeHostUrl === hostUrl) {
                        this._activeHostUrl = cleanUrl;
                    }
                    this._queue.push(task);
                }
                else {
                    res.arangojsHostUrl = hostUrl;
                    const contentType = res.headers["content-type"];
                    const queueTime = res.headers["x-arango-queue-time-seconds"];
                    if (queueTime) {
                        this._queueTimes.push([Date.now(), Number(queueTime)]);
                        while (this._responseQueueTimeSamples < this._queueTimes.length) {
                            this._queueTimes.shift();
                        }
                    }
                    let parsedBody = undefined;
                    if (res.body.length && contentType && contentType.match(MIME_JSON)) {
                        try {
                            parsedBody = res.body;
                            parsedBody = JSON.parse(parsedBody);
                        }
                        catch (e) {
                            if (!task.options.expectBinary) {
                                if (typeof parsedBody !== "string") {
                                    parsedBody = res.body.toString("utf-8");
                                }
                                e.res = res;
                                if (task.stack) {
                                    e.stack += task.stack();
                                }
                                callback(e);
                                return;
                            }
                        }
                    }
                    else if (res.body && !task.options.expectBinary) {
                        parsedBody = res.body.toString("utf-8");
                    }
                    else {
                        parsedBody = res.body;
                    }
                    if ((0, error_1.isArangoErrorResponse)(parsedBody)) {
                        res.body = parsedBody;
                        err = new error_1.ArangoError(res);
                    }
                    else if (res.statusCode && res.statusCode >= 400) {
                        res.body = parsedBody;
                        err = new error_1.HttpError(res);
                    }
                    else {
                        if (!task.options.expectBinary)
                            res.body = parsedBody;
                        task.resolve(task.transform ? task.transform(res) : res);
                    }
                }
            }
            if (err) {
                if (!task.allowDirtyRead &&
                    this._hosts.length > 1 &&
                    this._activeHostUrl === hostUrl &&
                    this._loadBalancingStrategy !== "ROUND_ROBIN") {
                    this._activeHostUrl =
                        this._hostUrls[(this._hostUrls.indexOf(this._activeHostUrl) + 1) %
                            this._hostUrls.length];
                }
                if ((0, error_1.isArangoError)(err) &&
                    err.errorNum === codes_1.ERROR_ARANGO_CONFLICT &&
                    task.retryOnConflict > 0) {
                    task.retryOnConflict -= 1;
                    this._queue.push(task);
                }
                else if ((((0, error_1.isSystemError)(err) &&
                    err.syscall === "connect" &&
                    err.code === "ECONNREFUSED") ||
                    ((0, error_1.isArangoError)(err) &&
                        err.errorNum === codes_1.ERROR_ARANGO_MAINTENANCE_MODE)) &&
                    task.hostUrl === undefined &&
                    this._maxRetries !== false &&
                    task.retries < (this._maxRetries || this._hosts.length - 1)) {
                    task.retries += 1;
                    this._queue.push(task);
                }
                else {
                    if (task.stack) {
                        err.stack += task.stack();
                    }
                    task.reject(err);
                }
            }
            this._runQueue();
        };
        try {
            this._hosts[this._hostUrls.indexOf(hostUrl)](task.options, callback);
        }
        catch (e) {
            callback(e);
        }
    }
    _buildUrl({ basePath, path, qs }) {
        const pathname = `${basePath || ""}${path || ""}`;
        let search;
        if (qs) {
            if (typeof qs === "string")
                search = `?${qs}`;
            else
                search = `?${(0, querystringify_1.querystringify)(qs)}`;
        }
        return search ? { pathname, search } : { pathname };
    }
    setBearerAuth(auth) {
        this.setHeader("authorization", `Bearer ${auth.token}`);
    }
    setBasicAuth(auth) {
        this.setHeader("authorization", `Basic ${(0, btoa_1.base64Encode)(`${auth.username}:${auth.password}`)}`);
    }
    setResponseQueueTimeSamples(responseQueueTimeSamples) {
        if (responseQueueTimeSamples < 0) {
            responseQueueTimeSamples = Infinity;
        }
        this._responseQueueTimeSamples = responseQueueTimeSamples;
        while (this._responseQueueTimeSamples < this._queueTimes.length) {
            this._queueTimes.shift();
        }
    }
    database(databaseName, database) {
        if (database === null) {
            this._databases.delete(databaseName);
            return undefined;
        }
        if (!database) {
            return this._databases.get(databaseName);
        }
        this._databases.set(databaseName, database);
        return database;
    }
    /**
     * @internal
     *
     * Replaces the host list with the given URLs.
     *
     * See {@link Connection#acquireHostList}.
     *
     * @param urls - URLs to use as host list.
     */
    setHostList(urls) {
        const cleanUrls = urls.map((url) => (0, normalizeUrl_1.normalizeUrl)(url));
        this._hosts.splice(0, this._hosts.length, ...cleanUrls.map((url) => {
            const i = this._hostUrls.indexOf(url);
            if (i !== -1)
                return this._hosts[i];
            return (0, request_1.createRequest)(url, this._agentOptions, this._agent);
        }));
        this._hostUrls.splice(0, this._hostUrls.length, ...cleanUrls);
    }
    /**
     * @internal
     *
     * Adds the given URL or URLs to the host list.
     *
     * See {@link Connection#acquireHostList}.
     *
     * @param urls - URL or URLs to add.
     */
    addToHostList(urls) {
        const cleanUrls = (Array.isArray(urls) ? urls : [urls]).map((url) => (0, normalizeUrl_1.normalizeUrl)(url));
        const newUrls = cleanUrls.filter((url) => this._hostUrls.indexOf(url) === -1);
        this._hostUrls.push(...newUrls);
        this._hosts.push(...newUrls.map((url) => (0, request_1.createRequest)(url, this._agentOptions, this._agent)));
        return cleanUrls;
    }
    /**
     * @internal
     *
     * Sets the connection's active `transactionId`.
     *
     * While set, all requests will use this ID, ensuring the requests are executed
     * within the transaction if possible. Setting the ID manually may cause
     * unexpected behavior.
     *
     * See also {@link Connection#clearTransactionId}.
     *
     * @param transactionId - ID of the active transaction.
     */
    setTransactionId(transactionId) {
        this._transactionId = transactionId;
    }
    /**
     * @internal
     *
     * Clears the connection's active `transactionId`.
     */
    clearTransactionId() {
        this._transactionId = null;
    }
    /**
     * @internal
     *
     * Sets the header `headerName` with the given `value` or clears the header if
     * `value` is `null`.
     *
     * @param headerName - Name of the header to set.
     * @param value - Value of the header.
     */
    setHeader(headerName, value) {
        if (value === null) {
            delete this._headers[headerName];
        }
        else {
            this._headers[headerName] = value;
        }
    }
    /**
     * @internal
     *
     * Closes all open connections.
     *
     * See {@link database.Database#close}.
     */
    close() {
        for (const host of this._hosts) {
            if (host.close)
                host.close();
        }
    }
    /**
     * @internal
     *
     * Waits for propagation.
     *
     * See {@link database.Database#waitForPropagation}.
     *
     * @param request - Request to perform against each coordinator.
     * @param timeout - Maximum number of milliseconds to wait for propagation.
     */
    async waitForPropagation(request, timeout = Infinity) {
        const numHosts = this._hosts.length;
        const propagated = [];
        const started = Date.now();
        let index = 0;
        while (true) {
            if (propagated.length === numHosts) {
                return;
            }
            while (propagated.includes(this._hostUrls[index])) {
                index = (index + 1) % numHosts;
            }
            const hostUrl = this._hostUrls[index];
            try {
                await this.request({ ...request, hostUrl });
            }
            catch (e) {
                if (started + timeout < Date.now()) {
                    throw e;
                }
                await new Promise((resolve) => setTimeout(resolve, 1000));
                continue;
            }
            if (!propagated.includes(hostUrl)) {
                propagated.push(hostUrl);
            }
        }
    }
    /**
     * @internal
     *
     * Performs a request using the arangojs connection pool.
     */
    request({ hostUrl, method = "GET", body, expectBinary = false, isBinary = false, allowDirtyRead = false, retryOnConflict = this._retryOnConflict, timeout = 0, headers, ...urlInfo }, transform) {
        return new Promise((resolve, reject) => {
            let contentType = "text/plain";
            if (isBinary) {
                contentType = "application/octet-stream";
            }
            else if (body) {
                if (typeof body === "object") {
                    body = JSON.stringify(body);
                    contentType = "application/json";
                }
                else {
                    body = String(body);
                }
            }
            const extraHeaders = {
                ...this._headers,
                "content-type": contentType,
                "x-arango-version": String(this._arangoVersion),
                "x-arango-driver": `arangojs/8.3.0 (cloud)`,
            };
            if (this._transactionId) {
                extraHeaders["x-arango-trx-id"] = this._transactionId;
            }
            const task = {
                retries: 0,
                hostUrl,
                allowDirtyRead,
                retryOnConflict,
                options: {
                    url: this._buildUrl(urlInfo),
                    headers: { ...extraHeaders, ...headers },
                    timeout,
                    method,
                    expectBinary,
                    body,
                },
                reject,
                resolve,
                transform,
            };
            if (this._precaptureStackTraces) {
                if (typeof Error.captureStackTrace === "function") {
                    const capture = {};
                    Error.captureStackTrace(capture);
                    task.stack = () => `\n${capture.stack.split("\n").slice(3).join("\n")}`;
                }
                else {
                    const capture = generateStackTrace();
                    if (Object.prototype.hasOwnProperty.call(capture, "stack")) {
                        task.stack = () => `\n${capture.stack.split("\n").slice(4).join("\n")}`;
                    }
                }
            }
            this._queue.push(task);
            this._runQueue();
        });
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map